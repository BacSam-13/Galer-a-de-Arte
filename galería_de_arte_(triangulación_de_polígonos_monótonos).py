# -*- coding: utf-8 -*-
"""Galería de Arte (Triangulación de Polígonos Monótonos).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zpwvnisHvfGXyq6lW2BIZlL54_jFjAXA

Autor: Baruc Samuel Cabrera García

# **Galería de Arte**
# Generación de polígonos monótonos y su trinangulazisación

# Librerías necesarias
"""

from collections import deque
import matplotlib.pyplot as plt
import math
import random
import queue
import numpy as np
import copy

pi = np.pi
inf = np.inf

"""# RBT
Para emplear el algoritmo, es recomendable usar un RBT.
Se usara la siguiente implementación ya establecida, la cual se adaptara a las clases de datos que se declararan mas adelante al sobrecargar los operadores.
La versión original se encuentra en el sigueinte link pero se realizaron modificaciones para adaptarse al problema en cuestión:
https://favtutor.com/blogs/red-black-tree-python

"""

# Deinimos al nodo
class Node():
    def __init__(self,val):
        self.val = val # Valor del nodo
        self.parent = None # Padre
        self.left = None # Hijo izquierdo
        self.right = None # Hijo derecho
        self.color = "Red" # Color base de nodo

    def print(self):
        self.val.print()

# Definimos un RBTree
class RBTree():
    def __init__(self):
        self.NULL = Node ( None )
        self.NULL.color = "Black"
        self.NULL.left = None
        self.NULL.right = None
        self.root = self.NULL

    def search(self, key):
        #print("Se inicio search:")
        return self._search_recursion(self.root, key)

    def _search_recursion(self, node, key): # Funcion recursiva que busca la llave "key" en el subarbol node
        if node == self.NULL or node.val == key: # Si llegamos a un final o encontramos al nodo
          return node
        if key < node.val: # Si seguimos buscando en el subarbol izquierdo
            #print("<----")
            return self._search_recursion(node.left, key)
        #print("---->")
        return self._search_recursion(node.right, key) # Si seguimos buscando en el subarbol derecho

    # Insertar nodo
    def insert(self, key):
        node = Node(key)
        node.parent = None
        node.val = key
        node.left = self.NULL
        node.right = self.NULL
        node.color = "Red"

        y = None
        x = self.root

        while x != self.NULL : # Buscamos la posicion para el nuevo nodo
            y = x
            #node.val.print()
            #x.val.print()
            if node.val < x.val :
                x = x.left
            else :
                x = x.right

        node.parent = y # El padre del nodo sera y
        if y == None : # Si estamos en la raiz
            self.root = node
        elif node.val < y.val : # Determinamos si el nodo es hijo derecho o izquierdo
            y.left = node
        else :
            y.right = node

        if node.parent == None : # Root node is always Black
            node.color = "Black"
            return

        if node.parent.parent == None : # If parent of node is Root Node
            return

        self.fixInsert ( node ) # Else call for Fix Up


    def minimum(self, node): # Regresa el minimo del subarbol node
        while node.left != self.NULL:
            node = node.left
        return node


    def vecino_derecho_idx(self, id): # Obtenemos el indice del vecino derecho del nodo con "val"

      inorder = self.inorder_transversal_keys()
      ids_inorder = [] # Obtenemos los indices de los segmentos inorder
      for s in inorder:
        ids_inorder.append(s.id)

      idx = ids_inorder.index(id) # Tomamos la posicion donde esta id
      if idx + 1 < len(ids_inorder):
        return idx + 1
      return -1

    def maximum(self, node): # Obtiene el nodo maximo del subarbol node
        while node.right != self.NULL:
            node = node.right
        return node

    def vecino_izquierdo_idx(self, id): # Obtenemos el indice del vecino izquierdo del nodo con id

      inorder = self.inorder_transversal_keys()
      ids_inorder = [] # Obtenemos los indices de los segmentos inorder
      for s in inorder:
        ids_inorder.append(s.id)

      idx = ids_inorder.index(id) # Tomamos la posicion donde esta id
      if idx - 1 >= 0:
        return idx - 1
      return -1

    def pop_minimum(self):
        node = self.minimum(self.root)
        self.delete_node(node.val)
        return node

    # Rotacion izquierda
    def LR ( self , x ) :
        y = x.right
        x.right = y.left
        if y.left != self.NULL :
            y.left.parent = x

        y.parent = x.parent
        if x.parent == None :
            self.root = y
        elif x == x.parent.left :
            x.parent.left = y
        else :
            x.parent.right = y
        y.left = x
        x.parent = y


    # Rotacion derecha
    def RR ( self , x ) :
        y = x.left
        x.left = y.right
        if y.right != self.NULL :
            y.right.parent = x

        y.parent = x.parent
        if x.parent == None :
            self.root = y
        elif x == x.parent.right :
            x.parent.right = y
        else :
            x.parent.left = y
        y.right = x
        x.parent = y


    # Arreglar una insercion
    def fixInsert(self, k):
        while k.parent.color == "Red":
            if k.parent == k.parent.parent.right:
                u = k.parent.parent.left
                if u.color == "Red":
                    u.color = "Black"
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    k = k.parent.parent
                else:
                    if k == k.parent.left:
                        k = k.parent
                        self.RR(k)
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    self.LR(k.parent.parent)
            else:
                u = k.parent.parent.right
                if u.color == "Red":
                    u.color = "Black"
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    k = k.parent.parent
                else:
                    if k == k.parent.right:
                        k = k.parent
                        self.LR(k)
                    k.parent.color = "Black"
                    k.parent.parent.color = "Red"
                    self.RR(k.parent.parent)
            if k == self.root:
                break
        self.root.color = "Black"



    # Arreglar una eliminacion
    def fixDelete(self, x):
        while x != self.root and x.color == "Black":
            if x == x.parent.left:
                s = x.parent.right
                if s.color == "Red":
                    s.color = "Black"
                    x.parent.color = "Red"
                    self.LR(x.parent)
                    s = x.parent.right

                if s.left.color == "Black" and s.right.color == "Black":
                    s.color = "Red"
                    x = x.parent
                else:
                    if s.right.color == "Black":
                        s.left.color = "Black"
                        s.color = "Red"
                        self.RR(s)
                        s = x.parent.right

                    s.color = x.parent.color
                    x.parent.color = "Black"
                    s.right.color = "Black"
                    self.LR(x.parent)
                    x = self.root
            else:
                s = x.parent.left
                if s.color == "Red":
                    s.color = "Black"
                    x.parent.color = "Red"
                    self.RR(x.parent)
                    s = x.parent.left

                if s.right.color == "Black" and s.right.color == "Black":
                    s.color = "Red"
                    x = x.parent
                else:
                    if s.left.color == "Black":
                        s.right.color = "Black"
                        s.color = "Red"
                        self.LR(s)
                        s = x.parent.left

                    s.color = x.parent.color
                    x.parent.color = "Black"
                    s.left.color = "Black"
                    self.RR(x.parent)
                    x = self.root
        x.color = "Black"



    # Transplantar nodos
    def __rb_transplant ( self , u , v ) :
        if u.parent == None :
            self.root = v
        elif u == u.parent.left :
            u.parent.left = v
        else :
            u.parent.right = v
        v.parent = u.parent


    # Funcion recursiva para eliminar nodo
    def delete_node_helper ( self , node , key ) :
        z = self.NULL
        while node != self.NULL :
            #node.val.print()
            #print("//////////")
            if node.val == key :
                z = node

            if key < node.val :
                node = node.left
            else :
                node = node.right

        if z == self.NULL :
            #print ( "No se encontro el valor" )
            return

        y = z
        y_original_color = y.color
        if z.left == self.NULL :
            x = z.right
            self.__rb_transplant ( z , z.right )
        elif (z.right == self.NULL) :
            x = z.left
            self.__rb_transplant ( z , z.left )
        else :
            y = self.minimum ( z.right )
            y_original_color = y.color
            x = y.right
            if y.parent == z :
                x.parent = y
            else :
                self.__rb_transplant ( y , y.right )
                y.right = z.right
                y.right.parent = y

            self.__rb_transplant ( z , y )
            y.left = z.left
            y.left.parent = y
            y.color = z.color
        if y_original_color == "Black" :
            self.fixDelete ( x )


    # Borramos el nodo con el valor "val"
    def delete_node ( self , val ) :
        self.delete_node_helper ( self.root , val )

    # Genera un arreglo con los nodos in order
    def inorder_tranversal(self):
        nodes = []
        self._inorder_traversal_recursive(self.root, nodes)
        return nodes

    # Funcion auxiliar recursiva
    def _inorder_traversal_recursive(self, node, nodes):
        if node != self.NULL:
            self._inorder_traversal_recursive(node.left, nodes)
            nodes.append(node)
            self._inorder_traversal_recursive(node.right, nodes)

    # Obtiene el inorden del arbol pero solo regresa las keys
    def inorder_transversal_keys(self):

        nodes = self.inorder_tranversal() # Obtenemos los nodos actuales

        # Obtenemos unicamente los segmentos
        segmentos_actuales= []
        for n in nodes:
          segmentos_actuales.append(n.val)

        return segmentos_actuales

    def inorder_transversal_ids(self):
        keys = self.inorder_transversal_keys()

        ids = []
        for k in keys:
          ids.append(k.val.id)
        return ids

    def state(self):
      data = self.inorder_transversal_keys()
      print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
      for d in data:
        d.print()
        print("-------")
      print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
    def is_empty(self):
        if self.root == self.NULL:
            return True

    # Function to print
    def __printCall ( self , node , indent , last ) :
        if node != self.NULL :
            print(indent, end=' ')
            if last :
                print ("R----",end= ' ')
                indent += "     "
            else :
                print("L----",end=' ')
                indent += "|    "

            s_color = "RED" if node.color == 1 else "BLACK"
            print ( str ( node.val ) + "(" + s_color + ")" )
            self.__printCall ( node.left , indent , False )
            self.__printCall ( node.right , indent , True )

    # Function to call print
    def print_tree ( self ) :
        self.__printCall ( self.root , "" , True )

"""# Clases de datos"""

height_sweepline = np.inf
FLAG_HEDGE = True # Bandera para determinar como ordenar hedges (Se ocupan dos ordenamientos en partes distintas del codigo)

# Puntos  (p esta encima de q <-> p < q)
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y

  def print(self):
    print(f"({self.x}, {self.y})")

  def __lt__(self, other):
    if self.y == other.y:
      return self.x < other.x
    return self.y > other.y

  def __gt__(self, other):
    if self.y == other.y:
      return self.x > other.x
    return self.y < other.y

  def __eq__(self, other):
    return (self.x == other.x) and (self.y == other.y)
#######################################

class vertice:
  def __init__(self,punto):
    self.p = punto
    self.tipo = None
    self.hedgelist = [] # Para guardar las aristas que salen desde el
    self.chain = None
    self.color = None # Se colorearan según se haga DFS sobre las caras

  def sortincident(self): # Ordenamos las aristas incidentes
    self.hedgelist.sort(reverse=True)
    #self.hedgelist.sort(hsort, reverse=True)
    #self.hedgelist = sorted(self.hedgelist, key=hsort, reverse=True)

  def print(self):
    self.p.print()

  def __lt__(self, other):
    return self.p < other.p

  def __gt__(self, other):
    return self.p > other.p

  def __eq__(self, other):
    return self.p == other.p

  def print(self):
    self.p.print()


################################ Face
class Face:
  def __init__(self):
    #self.external = None # Por si es la cara externa
    self.wedge = None # Hedge asociada
    self.color = 'white' # Para realizar DFS sobre las caras
    #self.n_face = None # Numero id de la cara
    #self.pi = None # Para realizar DFS sobre las caras


  def area(self): # Se calcula el area según el método de Gauss
    h = self.wedge
    a = 0
    while(not h.next is self.wedge):
      p1 = h.origin.p
      p2 = h.twin.origin.p
      a += p1.x*p2.y - p2.x*p1.y
      h = h.next

    # Sumamos el valor restante que no se conto en el while
    p1 = h.origin.p
    p2 = h.twin.origin.p
    a += p1.x*p2.y - p2.x*p1.y
    return a / 2

  def print(self):
    aux = self.wedge
    aux.print()

    origen = aux.origin
    aux = aux.next
    while aux.origin != origen:
      aux.print()
      aux = aux.next

  def get_hedges(self):
    Hedges = []
    aux = self.wedge
    Hedges.append(aux)

    origen = aux.origin
    aux = aux.next
    while aux.origin != origen:
      Hedges.append(aux)
      aux = aux.next

    return Hedges

  def count_colors(self): # Contamos cuantos vertices de la cara ya estan coloreados
    count = 0
    for hedge in self.get_hedges():
      if hedge.origin.color is None:
        continue
      count += 1
    return count

  def __lt__(self, other):
    return self.count_colors() < other.count_colors()

  def __gt__(self, other):
    return self.count_colors() > other.count_colors()

  def colorear_vertices(self): # Coloreamos los vertices de la cara, según los colores faltantes. Ademas llevamos registro de cuantos vertices de cada color hay en total
    global n_white, n_black, n_gray
    hedges = self.get_hedges()
    Vertices = []
    Colores = ['black', 'white', 'gray'] # Colores para colorear

    for he in hedges: # Vertices a colorear
      Vertices.append(he.origin)

    print("°°°°°°°°°°°°°°°°°°°°°°° Buscamos colorear la cara con los vertices")
    for v in Vertices:
      v.print()
      print(v.color)
    print("\n")

    vertices_to_remove = []
    for v in Vertices:
      print(v.color)
      if v.color is None:
        continue

      # Si el vertice ya fue coloreado, eliminamos su color y ya no coloreamos al vertice
      print(f"Ya se tiene un vertice {v.color}")
      Colores.remove(v.color)
      vertices_to_remove.append(v)
      #Vertices.remove(v)
    for v in vertices_to_remove:
      Vertices.remove(v)
    print("\n")

    print("Solo colorearemos los vertices")
    for v in Vertices:
      v.print()
      print(v.color)
    print("\n")

    for i in range(len(Colores)): # Coloreamos el resto de vertices con los colores restantes
      color_i = Colores[i]
      Vertices[i].color = color_i

      if color_i == 'white':
        n_white += 1
        #print("Hay un vertice blanco")
      elif color_i == 'black':
        #print("Hay un vertice negro")
        n_black += 1
      else:
        #print("Hay un vertice gris")
        n_gray += 1
    #print("\n")


################################ Half edges
class half_edge:
    def __init__(self,vi,vj):
        #The origin is defined as the vertex it points to
        self.origin = vi
        self.twin = None
        self.next = None
        self.prev = None
        self.face = None # Ayuda a saber si la arista tiene a su izquierda el interior del poligono o no
        self.helper = None
        self.incident_face = None

    def get_point_on_height(self, h): #Regresa el punto del segmento que esta a altura h
      # Se asume que el segmento no es horizontal
      a = self.origin.p
      b = self.twin.origin.p

      if a < b:
        up = a
        low = b
      else:
        up = b
        low = a

      if h > up.y or low.y > h: # Si la sweepline no esta en el segmento
        return None

      Ay = up.y
      By = low.y

      Ax = up.x
      Bx = low.x

      if Ay == By: # Caso particular donde el segmento es horizontal
        return up

      t = (h - Ay)/(By-Ay)

      x_coord = Ax*(1-t) + Bx*t

      return Point(x_coord, h)

    def __lt__(self, other):
      A = self.get_point_on_height(height_sweepline)
      B = other.get_point_on_height(height_sweepline)

      return A < B

    def __gt__(self, other):
      A = self.get_point_on_height(height_sweepline)
      B = other.get_point_on_height(height_sweepline)

      return A > B

    def __eq__(self, other):
      A = self.get_point_on_height(height_sweepline)
      B = other.get_point_on_height(height_sweepline)

      return A == B

    def update_helper(self, v):
      self.helper = v
      self.twin.helper = v

    def print(self):
      #print(f"La cara de la arista es: {self.face}")
      #print("La arista empieza en:")
      a = self.origin
      b = self.twin.origin
      print(f"({a.p.x},{a.p.y}) ----> ({b.p.x},{b.p.y})")
      """if self.helper is None:
        print("Helper:")
        print("None")
      else:
        print("Helper:")
        self.helper.print()"""

"""#Funciones auxiliares y declaracion de casos"""

Coords = [[8,16], [12,14], [10,10], [12,6], [8,2], [4,3], [2,6], [6,8], [2,12], [6,11]] # Vertices en orden y sin cerrar (orden antihorario)
Coords.reverse() # En este caso, no se guardo en orden antihorario, así que se invierte
n = len(Coords)

puntos = []
aristas = []
for i in range(n):
  puntos.append(Point(Coords[i][0], Coords[i][1]))
  aristas.append([i, (i+1)%n])


"""
Nota:
  puntos: arreglo de puntos que forman los vértices del poligono
  aristas: arreglo de pares de puntos que forman las aristas en sentido antihorario (se guardan solo los indices)
"""

def generar_DCEL(P, A):
    # Creamos los vertices a base de los puntos P
    vertices = [vertice(punto) for punto in P]

    # Creamos las aristas segun los pares de indices de A
    aristas = [(vertices[i], vertices[j]) for i, j in A]

    # Creamos las half_edges a partir de aristas
    half_edges = []
    for vi, vj in aristas: # Creamos dos half_edges por cada arista
        he1 = half_edge(vi, vj)
        he2 = half_edge(vj, vi)

        he1.face = 1  # Sentido antihorario
        he2.face = -1 # Sentido horario

        he1.twin = he2
        he2.twin = he1

        vi.hedgelist.append(he1)
        vj.hedgelist.append(he2)

        half_edges.append(he1)
        half_edges.append(he2)

    # Asignamos las referencias .next y .prev
    # Notemos que half_edges esta froamdo para que half_edges[i] y half_edges[i+1] sean twins para toda i par, donde half_edges[i] va en el sentido antihorario (correcto).
    # Ya que las aristas se ingresaron en el sentido antihorario, se tiene que half_edges[(i+2)%n] es el next de half_edges[i] (n = len(half_edges)).
    # Usando esa misma logica, se tiene que half_edges[(i-2)%m] es el next de half_edges[i], para toda i impar
    # Con esto, podemos hacer un recorrido en ambos sentidos, para encontrar .next y .prev de cada half_edge
    n = len(half_edges)
    for i in range(0, n, 2): # Tomamos todos los i's pares
        he_i  = half_edges[i]
        he_i_next = half_edges[(i+2)%n]

        he_i.next = he_i_next
        he_i.twin.prev = he_i_next.twin

    for i in range(n-1, 0, -2):
        he_i  = half_edges[i]
        he_i_next = half_edges[(i-2)%n]

        he_i.next = he_i_next
        he_i.twin.prev = he_i_next.twin
    # Devolver la DCEL completa
    return vertices, half_edges

Vertices, Half_Edges = generar_DCEL(puntos, aristas)

# Considerando el segmento p -> q, nos indica en que lado esta r
def orientation(p,q,r):
  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
  if val == 0:
    #print("En segmento")
    return 0
  elif val > 0:
    #print("Derecha")
    return 1
  else:
    #print("Izquierda")
    return -1

def get_neighbors(v): # Se obtienen los puntos finales de la half edge incidente de v que sigue el sentido antihorario, y de la que sigue el sentido horario
  aristas = v.hedgelist
  for a in aristas:
    if a.face == 1: # Si la arista a tiene a su izquierda el interior del poligono
      end = a.twin.origin
    else: # Si la arista a tiene a su izquierda el exterior del poligono
      start = a.twin.origin

  # end: e_i
  # start: e_i+1
  return end, start

def get_edges(v_i): # Usando a v_i, se regresan e_i y e_i-1
  aristas = v_i.hedgelist
  for a in aristas:
    if a.face == 1: # Si la arista a tiene a su izquierda el interior del poligono
      e_i = a
    else: # Si la arista a tiene a su izquierda el exterior del poligono
      e_i1 = a.twin

  return e_i, e_i1

# Nos indica el tipo de vertice que es
def type_of_point(v): # v es un vertice
  # Exploramos las aristas incidentes de v para encontrar a sus vecinos
  # Considerando que el poligono tiene sentido antihorario:
  #   start: Vecino previo
  #   end: Vecino siguiente

  if v.tipo != None:
    return v.tipo

  end, start = get_neighbors(v)
  # Recordemos que p esta encima de q sii p < q)

  if end > v and start > v: # Si los vecinos de v estan debajo de el
    if orientation(start.p, v.p, end.p) == -1: # El angulo interno es inferior a -pi
      v.tipo = "start"
      return "start"
    if orientation(start.p, v.p, end.p) == 1: # El angulo interno es mayor a pi
      v.tipo = "split"
      return "split"

  if end < v and start < v: # Si los vecinos de v estan encima de el
    if orientation(start.p, v.p, end.p) == -1: # El angulo interno es inferior a -pi
      v.tipo = "end"
      return "end"
    if orientation(start.p, v.p, end.p) == 1: # El angulo interno es mayor a pi
      v.tipo = "merge"
      return "merge"

  v.tipo = "regular"
  return "regular"

def get_ei(T, vj): # Se utiliza busqueda binaria sobre T, para encontrar el nodo.val maximo que sea menor que vj
    A = T.inorder_transversal_keys()

    """print("Se consideraran a los vecinos:\n------------------------------------")
    for a in A:
      a.print()
      print("\n")
    print("------------------------------------")"""
    low = 0 # Se asumira que el nodo.val que buscamos existe
    high = len(A) - 1
    result = None

    while low <= high:
        mid = (low + high) // 2

        if A[mid].get_point_on_height(vj.p.y) < vj.p:
            result = A[mid]
            low = mid + 1
        else:
            high = mid - 1

    return result

def create_edge(D, vi, vj): # Se busca crear la half_edge que conecta vi,vj. Respetando el sentido antihorario
  # Creamos las half_edges
  e_ij = half_edge(vi, vj)
  e_ji = half_edge(vj, vi)

  # Las hacemos twins entre si
  e_ij.twin = e_ji
  e_ji.twin = e_ij

  # Obtenemos e_i, e_i1 y e_j,e_j1 de vi y vj respectivamente
  e_i, e_i1 = get_edges(vi)
  e_j, e_j1 = get_edges(vj)

  # Usamos lo anterior para .prev y .next de e_ij, e_ji
  e_ij.prev = e_i1
  e_ij.next = e_j

  e_ji.prev = e_j1
  e_ji.next = e_i

  # Agregamos las aristas a los puntos v_i, v_j
  vi.hedgelist.append(e_ij)
  vj.hedgelist.append(e_ji)

  # Agregamos las aristas a D
  D.append(e_ij)
  D.append(e_ji)

# Funcion que el estado del poligono
def plot_state(Vertices, Half_Edges, D = None, Chains = False, Guards = False):
  plt.figure(figsize=(8, 8))
  c = 'red'
  arista_actual = Half_Edges[0]

  if arista_actual.face == -1:
    arista_actual = arista_actual.twin

  start = arista_actual.origin.p
  i = 0

  a = arista_actual.origin.p
  b = arista_actual.twin.origin.p
  mid_x = (a.x + b.x)/2
  mid_y = (a.y + b.y)/2

  if Chains == True:
    if arista_actual.origin.chain == "l":
      c = 'red'
    elif arista_actual.origin.chain == "r":
      c = 'c'
    else:
      c = 'purple'

  label_1 = f"v_{i}"
  label_2 = f"e_{i}"
  plt.scatter(a.x, a.y, color = c)
  plt.text(a.x, a.y, label_1, fontsize=12, ha='center', va='center')
  plt.plot([a.x, b.x], [a.y, b.y],color='blue')
  plt.text(mid_x, mid_y, label_2, fontsize=12, ha='center', va='center')


  arista_actual = arista_actual.next
  a = arista_actual.origin.p
  b = arista_actual.twin.origin.p
  i += 1

  while a != start:
    mid_x = (a.x + b.x)/2
    mid_y = (a.y + b.y)/2

    label_1 = f"v_{i}"
    label_2 = f"e_{i}"
    if Chains == True:
      if arista_actual.origin.chain == "l":
        c = 'red'
      elif arista_actual.origin.chain == "r":
        c = 'c'
      else:
        c = 'purple'
    plt.scatter(a.x, a.y, color=c)
    plt.text(a.x, a.y, label_1, fontsize=12, ha='center', va='center')
    plt.plot([a.x, b.x], [a.y, b.y],color='blue')
    plt.text(mid_x, mid_y, label_2, fontsize=12, ha='center', va='center')

    arista_actual = arista_actual.next
    a = arista_actual.origin.p
    b = arista_actual.twin.origin.p
    i += 1

  if D != None:

    for d in D:
      a = d.origin.p
      b = d.twin.origin.p
      plt.plot([a.x, b.x], [a.y, b.y],color='blue', linestyle = ":")


  plt.xlabel('X')
  plt.ylabel('Y')
  plt.title('Polígono')
  plt.grid(True)
  plt.axis('equal')
  plt.show()


#P.state()
print("\n")
#P.print()
plot_state(Vertices, Half_Edges)

"""# Convertir un polígono simple en monótonos

El objetivo, es el generar aristas dentro del polígono, las cuales eliminen a los vértices giro. Para esto se usara una línea de barrido desde arriba.

Ahora, consideremos los siguientes tipos de veritces:

1.  Start: Sus vecinos estan ambos abajo, y el angulo interno es inferior a pi

2.  Split: Sus vecinos estan ambos abajo, y el angulo interno es mayor a pi

3.  End: Sus vecinos estan ambos arriba y el angulo interno es mayor a pi

4.  Merge: Sus vecinos estan ambos arriba y el angulo interno es menor a pi

5. Regular: Otro caso

El objetivo, es eliminar a los vértices Split y Merge al agregar aristas a tales vértices. Es decir, aristas hacia arriba a los Split, y aristas hacia abajo a los Merge.

Ahora, una línea de barrido se movera hacia abajo, deteniendose en puntos evento (vertices ya establecidos).

Los puntos evento se guardaran en Q (priority queue).

Supongamos que los veritces {v_1,...,v_n} estan ordenados en sentido antihorario, y las aristas {e_1,...,e_n} son tales que e_i = [v_i,v_i+1], y e_n = [v_n,v_1]

La meta del barrido sera añadir aristas, y se tomaran dos enfoques según el tipo de vértice al que se le agregara la arista:

1. Split:

    Se buscara añadir diagonales del vertice aun verice cercano encima de el.

    Sea v_i el vertice en cuestion, definiremos como e_j y e_k como las aristas a su izquierda y derecha respectivamente.

    Definiremos a helper(e_j) como el vertice mas bajo sobre la linea de barrida tal que el segmento horizontal conectado con ej este dentro de P.

    En caso de no poder tomar un punto, se elige a v_j como default.

    Se busca conectar a v_i con helper(e_j)

2. Merge:

    Debemos tener en cuenta que no se ha explorado el plano debajo de la sweepline.

    Así que al llegar a v_i, este se registra como helper(e_j).

    Conectaremos a v_i con el primer vertice que aparezca sobre la línea entre e_j y e_k.



Ya que debemos encontrar las aristas a la izquierda de cada vertice, alacenamos las aristas que encuentra la línea de barrido en un BST "T".

Con cada arista en T, almacenamos a su ayudante.

T determina el estado de la línea de barrido.

Almacenaremos la subdivision en una lista doblemente ligada de aristas.

"""

# dcel es la clase que guarda las listas de aristas doblemente conectadas

def handle_start_vertex(T, v_i):
  e_i, e_i1 = get_edges(v_i)
  #e_i.print()
  #print("\n")
  T.insert(e_i)
  e_i.update_helper(v_i)
  #e_i.print()
  #print("\n")
  #T.state()

def handle_end_vertex(T, D, v_i):
  e_i, e_i1 = get_edges(v_i)

  if e_i1.helper.tipo == "merge":
    #print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Se inserto una diagonal:")
    #v_i.print()
    #e_i1.helper.print()
    create_edge(D, v_i, e_i1.helper )
    #D.append( v_i, e_i1.helper )
  T.delete_node(e_i1)

def handle_split_vertex(T, D, v_i):
  e_j = get_ei(T, v_i)
  #print("v_i:")
  #v_i.print()
  #print("e_j:")
  #e_j.print()

  #print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Se inserto una diagonal:")
  #v_i.print()
  #e_j.helper.print()
  create_edge(D, v_i, e_j.helper)
  #D.append(half_edge(v_i, e_j.helper))
  e_j.update_helper(v_i)
  e_i, e_i1 = get_edges(v_i)
  T.insert(e_i)
  e_i.update_helper(v_i)

def handle_merge_vertex(T, D, v_i):
    e_i, e_i1 = get_edges(v_i)

    if e_i1.helper.tipo == "merge":
      #print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Se inserto una diagonal:")
      #v_i.print()
      #e_i1.helper.print()
      create_edge(D, v_i, e_i1.helper)
      #D.append(half_edge(v_i, e_i1.helper))

    T.delete_node(e_i1)

    e_j = get_ei(T, v_i)

    if e_j.helper.tipo == "merge":
      #print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Se inserto una diagonal:")
      #v_i.print()
      #e_j.helper.print()
      create_edge(D, v_i, e_j.helper)
      #D.append(half_edge(v_i, e_j.helper))

    e_j.update_helper(v_i)

def handle_regular_vertex(T, D, v_i):
  start, end = get_neighbors(v_i)
  #print("Los vecinos del punto son:")
  #start.print()
  #end.print()
  #print("\n")
  e_i, e_i1 = get_edges(v_i)
  #print("Las aristas del punto son:")
  #e_i.print()
  #print("\n")
  #e_i1.print()
  #print("\n")

  if end < start: # Si [start, v_i, end] van hacia abajo, el interior de P esta a la derecha de v_i
    #print("El interior de P esta a la derecha del punto")
    if e_i1.helper.tipo == "merge":
      #print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Se inserto una diagonal:")
      #v_i.print()
      #e_i1.helper.print()
      create_edge(D, v_i, e_i1.helper)
      #D.append(half_edge(v_i, e_i1.helper))
    T.delete_node(e_i1)
    T.insert(e_i)
    e_i.update_helper(v_i)

  else: # Si [start, v_i, end] van hacia arriba, el interior de P esta a la izquierda de v_i
    #print("El interior de P esta a la izquierda del punto")
    e_j = get_ei(T, v_i)
    #print("e_j:")
    #e_j.print()
    if e_j.helper.tipo == "merge":
      #print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Se inserto una diagonal:")
      #v_i.print()
      #e_j.helper.print()
      create_edge(D, v_i, e_j.helper)
      #D.append(half_edge(v_i, e_j.helper))
    e_j.update_helper(v_i)

def make_monotone(Vertices): # P es un poligono simple ordenado en una DCEL "D". P es una clase DCEL
  global height_sweepline
  height_sweepline = np.inf # Comenzamos con la sweepline en el infinito, para luego bajarla por los event points (vertices)

  Q = RBTree() # Cola de prioridad para los vertices de P
  T = RBTree() # BST para las aristas
  D = []

  # Inicializamos a Q
  Q = RBTree()

  for v in Vertices:
    Q.insert(v)

  while not Q.is_empty():
    v_node = Q.pop_minimum() # Tomamos el vertice mas alto
    v = v_node.val

    #print("\n°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\nManejaremos el evento:")
    #v.print()

    height_sweepline = v.p.y
    # Llamamos a la funcion correspondiente para manejarlo según el tipo de vertice que sea
    tipo = type_of_point(v)
    #print(f"El evento es tipo {tipo}")

    if tipo == "start":
      handle_start_vertex(T, v)

    if tipo == "end":
      handle_end_vertex(T, D, v)

    if tipo == "split":
      handle_split_vertex(T, D, v)

    if tipo == "merge":
      handle_merge_vertex(T, D, v)

    if tipo == "regular":
      handle_regular_vertex(T, D, v)

  return D

D = make_monotone(Vertices)
plot_state(Vertices, Half_Edges, D)

"""**Generacion de Poligonos**

Con base en las aristas en D, se buscan extraer los poligonos para así extraerlos y triangularizarlos
"""

"""
Recordemos que para generar un poligono, necesitamos:
1.  Activar la bandera FLAG_HEDGE para el ordenamiento
2.  Tener un arreglo de puntos "Puntos" que forman los vértices del poligono (No ciclico)
3.  Tener un arreglo de aristas "Aristas" que forman las aristas del polígono en sentido antihorario, estas solo son los indices
"""

def check_curve(e, v): # Determina cual es la arista siguiente en base a la arista actual y hacia el vertice al que se dirige, y regresa la arista en cuestion
  if e.face is None: # Si la arista actual es una añadida
    #print("Esta arista es una ya añadida")
    return e.next

  if len(v.hedgelist) == 2: # Si v no tiene una arista añadida incidente
    #print("La arista no apunta a ningun vertice con arista añadida indcidente")
    return e.next

  #print("La arista apunta a un vertice con arista añadida incidente")
  # Por default, estamos en el caso donde una arista original, se dirige a un vertice con aristas añadidas
  for edge in v.hedgelist: # Vemos sus aristas
    if edge.face is None and v == edge.origin: # Regresamos la arista añadida que comienza en v
      edge.face = 1 # Marcamos que ya fue asignada a un poligono
      return edge


def extract_Poligonos(D):
  n_poligonos = int((len(D)/2) + 1)

  Vertices = [None] * n_poligonos # Aristas
  Half_Edges = [None] * n_poligonos # Coordenadas

  idx_pol = 0 # Para llevar la cuenta de los poligonos que se crean

  for edge in D:
    #print("----------------------------------")

    if edge.face is not None: # Si la arista ya fue asignada a un poligono
      #print("Ya fue asignada a un poligono")
      continue

    end_point = edge.origin.p # El punto donde empieza la primera arista tambien es donde debe terminar la ultima arista

    Puntos = [] # Guardar los puntos en sentido antihorario
    Aristas = [] # Guardar indices en sentido antihorario


    Puntos.append(edge.origin.p) # Añadimos el punto inicial

    actual_edge = edge
    j = 0
    while True:
      #print("°°°°°°°°°°°°°\t\tEstamos ahora en la arista:")
      #actual_edge.print()
      #print(f"Face: {actual_edge.face}")

      next_vertice = actual_edge.twin.origin

      if next_vertice.p == end_point: # Si llegamos a la ultima arista
        Aristas.append([j, 0])
        actual_edge = check_curve(actual_edge, next_vertice)
        actual_edge.face = 1
        break

      Puntos.append(next_vertice.p)
      Aristas.append([j,j+1])

      j += 1
      actual_edge = check_curve(actual_edge, next_vertice)


    Vertices[idx_pol], Half_Edges[idx_pol] =  generar_DCEL(Puntos, Aristas)
    idx_pol += 1

  return  Vertices, Half_Edges

Vertices_list, Half_Edges_list = extract_Poligonos(D)

n_monotonos = len(Vertices_list)

for i in range(n_monotonos):
  plot_state(Vertices_list[i], Half_Edges_list[i])

"""**Triangulación de Polígonos Monótonos**

Procederemos a implementar el algoritmo de triangulación de polígonos monótonos para triangular los polígonos ya calculados

Para la triangulalización del polígono, se utiliza una pila S, la cual contendra a los vértices del polígono que han sido encontrados, pueden requerir mas diagonales.

Al manejar un vértice, le agregamos cuantas aristas podamos entre este y los vérticesde S.

Los vértices que se encuentren en S (no han sido divididos), son la frontera de la parte de P que aun requiere ser triangulada}

La parte de S en P, parece un embudo de cabeza. Una frontera del embudo consiste en una sola arista de P, y la otra frontera es una cadena de vértices reflex. Unicamente el mas alto de estos es convexo.

Ahora, se consideran dos casos:

  1. v_j, el siguiente vertice en ser manejado, se encuentra en la misma cadena que los vertices refles en S.
  
  Puede ser posible conectar a v_j con los vertices en la cima de S. Hacemos esto hasta que no se pueda conectar, entonces pusheamos el ultimo vertice popeado (el que no se pudo conectar) a S. Este sera el último de los vértices, o el vecino de v_j en la frontera de P.

  2. v_j es el siguiente vértice en ser manejado, se encuentra en la cadena opuestaa los vértices reflex en S.

  v_j debe ser el lower endpoint de la arista envolviendo al embudo. Podemos añadir aristas adicionales desde v_j a todos los vértices de S, a exepción del último.
  Todos estos vértices son popeados de S.
"""

def separate_chains(Vertices): # Cambiamos el atributo de los vertices de un poligono monotono en sentido antihorario
  Vertices_ordenados = sorted(Vertices)

  top = Vertices_ordenados[0] # vertice mas alto
  bottom = Vertices_ordenados[-1] # vertice mas bajo

  Vertices_ordenados[0].chain = "lr" # Comodin
  Vertices_ordenados[-1].chain = "lr" # Comodin

  # Encontramos las aristas que salen de top y bottom respectivamente que vayan en sentido antihorario
  for h_edge in top.hedgelist:
    if h_edge.face == 1:
      hedge_top = h_edge

  for h_edge in bottom.hedgelist:
    if h_edge.face == 1:
      hedge_bottom = h_edge

  actual_left = hedge_top.next.origin
  while actual_left != bottom:
    actual_left.chain = "l" # El vertice esta en la cadena izquierda
    hedge_top = hedge_top.next # Pasamos a la siguiente arista
    actual_left = hedge_top.origin # Tomamos el origen de la nueva arista

  actual_right = hedge_bottom.next.origin
  while actual_right != top:
    actual_right.chain = "r" # El vertice esta en la cadena derecha
    hedge_bottom = hedge_bottom.next # Pasamos a la siguiente arista
    actual_right = hedge_bottom.origin # Tomamos el origen de la nueva arista


# Segmentos
class Segment:
  def __init__(self, up, low): # Punto superior, punto inferior, id del segmento, altura de la sweepline (debe ser igual a la de uno de sus extremos)
    # Organizamos los puntos para que el mas alto (menor) sea up
    if up < low:
      self.up = up # Punto superior
      self.low = low # Punto inferior
    else:
      self.up = low # Punto superior
      self.low = up # Punto inferior


# Funcion para determinar si dos segmentos se intersectan (Omitiremos donde la interseccion es uno de lo extremos)
def do_intersect(s1, s2):
  # Obtenemos los puntos de cada segmento
  p1, q1 = s1.up, s1.low
  p2, q2 = s2.up, s2.low

  if p1 == p2 or p1 == q2 or q1 == p2 or q1 == q2: # Si la interseccion es entre extremos, no la contamos, a menos que sean colinales que
    if orientation(p1,q1,p2) == 0 and orientation(p1,q1,q2) == 0:
      return True
    return False

  #Recordemos que la intersección es solo válida si los dos segmentos se
  # intersectan en un solo punto que esta estrictamente dentro de ambos segmentos

  #Obtenemos las orientaciones de los puntos de cada segmento con el otro segmento
  o1 = orientation(p1, q1, p2)
  o2 = orientation(p1, q1, q2)
  o3 = orientation(p2, q2, p1)
  o4 = orientation(p2, q2, q1)

  # Ahora, consideraremos los siguientes casos para determinar si hay una interseccion

  # Si se cumple que ambos segmento forman una cruz
  if (o1 != o2 and o3 != o4):
    return True
  return False

# Para comprobar que separate_chains funciona bien
n_monotonos = len(Vertices_list)

for i in range(n_monotonos):
  separate_chains(Vertices_list[i])
  plot_state(Vertices_list[i], Half_Edges_list[i], Chains = True)

def is_in_P(a, b, Half_Edges): # Queremos saber si a,b esta dentro del poligono formado por Half_Edges

  print("La diagonal entre:")
  a.print()
  b.print()
  print("\n")
  n = len(Half_Edges)

  s1 = Segment(a.p, b.p)

  for i in range(0, n, 2): # Vemos solo las half_edges pares (sentido anti horario)
    w = Half_Edges[i].origin
    v = Half_Edges[i].twin.origin
    #print("Se evaluara con:")
    #w.print()
    #v.print()
    #print("\n")
    s2 = Segment(w.p,v.p)

    if do_intersect(s1, s2): # Si s1 intersecta a s2, no esta en P
      print("No esta dentro del polígono")
      return False

  print("Esta dentro del polígono")
  return True

def state_S(S):
  n = len(S)
  print("El estado de la stack S es:")
  for i in range(n-1, -1, -1):
    S[i].print()
  print("\n")

def Triangulate_Monotone_Polygon(Vertices, Half_Edges):
  #print("---------------------- A triangularizar un polígono ----------------------")
  U = sorted(Vertices) # Veritces ordenados
  n = len(U)
  S = [] # Pila S
  S.append(U[0])
  S.append(U[1])

  #state_S(S)

  D = [] # Para guardar las diagonales para la triangulacización

  separate_chains(Vertices) # Separamos los vertices en cadena izquierda y derecha

  for j in range(2, n-1):
    #print("°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\nEvaluaremos a (u[j], S.top):")
    #U[j].print()
    #S[-1].print()
    #print("\n")

    if not(U[j].chain == "lr" or S[-1].chain == "lr"): # Si ningun vertice es top o bottom
      if U[j].chain != S[-1].chain: # Si U[j] y S[-1] no comparten cadena
        #print("No estan en la misma cadena \t Caso 1.")
        n_S = len(S)
        #print("xxxxxxxxxxxxxxxx Creamos diagonales entre: xxxxxxxxxxxxxxxx")
        #U[j].print()
        #print("con ->")
        for i in range(n_S):
          s = S.pop()
          """if i == 0: # Guardamos el top
            top = s"""
          if i != n_S - 1: # Si no estamos en el bottom de S, creamos una diagonal
            #s.print()
            create_edge(D, U[j], s)
        #print("\n")

        S.append(U[j-1])
        S.append(U[j])
        #state_S(S)

      else:
        #print("Estan en la misma cadena \t Caso 2.")
        prev_pop = S.pop() # Popeamos un vertice de S

        if U[j].chain == "r":
          dir = 1
        else:
          dir = -1

        while len(S) > 0: # Popeamos el resto de vertices de S
          #if is_in_P(U[j], S[-1], Half_Edges): # Si se puede formar la diagonal
          if orientation(U[j].p, prev_pop.p, S[-1].p) == dir: # Si se puede formar la diagonal
            #print("xxxxxxxxxxxxxxxx Creamos diagonales entre: xxxxxxxxxxxxxxxx")
            #U[j].print()
            #s.print()
            #print("\n")
            create_edge(D, U[j], s)
            prev_pop = S.pop() # Popeamos el vertice con el que se hizo la diagonal
          else:
            break
        S.append(prev_pop) # Insertamos el ultimo vertice popeado (el de la ultima diagonal o el top previo de S si no hay diagonales)
        S.append(U[j])
        #state_S(S)

  #state_S(S)
  for i in range(1, len(S)-1):
    create_edge(D, U[n-1], S[i])

  return D


def new_get_edges(v_i): # Usando a v_i, se regresan e_i y e_i-1
  aristas = v_i.hedgelist
  for a in aristas:
    if a.face == 1: # Si la arista a tiene a su izquierda el interior del poligono
      e_i = a
    elif a.face == -1: # Si la arista a tiene a su izquierda el exterior del poligono
      e_i1 = a.twin

  return e_i, e_i1

def update_edge(D, a, b): # Actualizamos los valores .next y .prev de las aristas regulares (originales del poligono) que tengan a "a" o "b" como extremos. La arista se encuentra en el top de D
  from_a, to_a = new_get_edges(a) # Tomamos las aristas que apuntan a "a" y salen de "a" respectivamente
  from_b, to_b = new_get_edges(b) # Tomamos las aristas que apuntan a "b" y salen de "b" respectivamente

  arista_ab = D[-1]

D_list = [None]*n_monotonos
for i in range(n_monotonos):
  D_list[i] = Triangulate_Monotone_Polygon(Vertices_list[i], Half_Edges_list[i])

for i in range(n_monotonos):
  plot_state(Vertices_list[i], Half_Edges_list[i], D_list[i])

"""**DFS**

Realizaremos DFS sobre los triángulso de los polígonos monótonos ya triangularizados, para así colorear los vértices con colores blanco, negro y gris, con la condición de que cada triángulo no tenga tres vértices coloreados igual. (Página 55 pdf)
"""

"""def get_faces(Hedges):
  Faces = [] # Para guardar las caras
  provlist = Hedges[:] # Lisra provisional de las hedge
  nf = 0 # Numero de caras
  nh = len(Hedges) # Numero de hedges

  while nh > 0:
      h = provlist.pop() # Tomamos una half_edge
      nh -= 1

      if h.incident_face == None: # Si aun no se le asigna una cara a la half_edge
          f = Face() # Creamos una cara
          nf += 1
          # Unimos la half_edge a la nueva cara
          f.wedge = h
          f.wedge.incident_face = f
          # Recorremos la frontera de la nueva cara
          while (not h.next is f.wedge):
              h = h.next # Suponemos que .next se actualizo para que siga el curso de las caras
              h.incident_face = f
          Faces.append(f)

  # Determinamos la cara externa
  for f in Faces:
    f.external = f.area() < 0

  return Faces"""


def get_faces(D): # Obtenemos las caras segun las diagonales de D (Omitiremos la cara externa)
  Faces = [] # Para guardar las caras

  for d in D:
    #print("Evaluamos la diagonal:")
    #d.print()
    if d.incident_face == None: # Si aun no registramos una cara a la diagonal
      #print("No tiene cara aun")
      f = Face() # Creamos una cara
      d.incident_face = f
      f.wedge = d # La arista asignada a la cara creada es d
      #f.wedge.incident_face = f # A la arista se damos a f como su cara incidente
      aux = d.next
      while aux.origin != d.origin: # Seguimos el recorrido de .next para que las aristas tengan a f como cara incidente
        aux.incident_face = f
        aux = aux.next
      Faces.append(f)

  return Faces

def arg(P): # Calcula el angulo del punto P respecto al eje x en [0,2pi)
  x = P.x
  y = P.y

  ang = math.atan2(y, x)
  if ang < 0:
    return 2*pi + ang
  return ang

def fix_DCEL(D):

  for d in D: # Tomamos una diagonal que une a dos veritces a -> b
    #print("°°°°°°°°°°°°°°°°°°°°°\nBuscaremos arreglar a la diagonal:")
    #d.print()
    a = d.origin
    b = d.twin.origin

    # d.next sera la arista que salga de b que minimice el angulo entre d y la misma
    # d.prev sera la arista que llegue a a que minimice el angulo entre la misma y d
    # En ambos casos, se consideraran solo aristas con .face == 1 y que sean distintas a d

    min_a = inf # angulo minimo para elegir d.prev
    for edge in a.hedgelist: # Exploramos las aristas que salen de a, para luego tomar sus twins, y tener las que llegan al vertice
      hedge = edge.twin
      if hedge.face == -1 or hedge.origin.p == b.p: # Que no sean half_edges externas, y no sean d.twin
        continue

      angulo = calcular_angulo(hedge.origin.p, a.p, b.p) # Angulo interno de hedge con ab
      if angulo < min_a: # Escogemos la arista que minimiza el angulo
        prev = hedge
        min_a = angulo
    # Actualizamos prev
    #print("\nSu previo fue:")
    #prev.print()
    #print(f"Angulo: {min_a}\n")
    prev.next = d
    d.prev = prev



    min_b = inf # angulo minimo para elegir d.next
    for edge in b.hedgelist: # Exploramos las aristas que salen de b
      if edge.face == -1 or a.p == edge.twin.origin.p: # Que no sean half_edges externas, y no sean d.twin
        continue
      angulo = calcular_angulo(a.p, b.p, edge.twin.origin.p) # Angulo interno de hedge con ab
      if angulo < min_b: # Escogemos la arista que minimiza el angulo
        next = edge
        min_b = angulo
    # Actualizamos prev
    #print("Su next fue:")
    #next.print()
    #print(f"Angulo: {min_b}\n")
    next.prev = d
    d.next = next

    if prev.origin != next.twin.origin:
      print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ERROR XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
      print("\nLas aristas incidentes de:")
      prev.print()
      d.prev.print()
      print("\n")
      d.print()
      print("\n")
      next.print()
      d.next.print()

      print("\n")
      print("Las aristas que salen de d son:")
      for edge in b.hedgelist:
        edge.print()
        print(f"\t\t{calcular_angulo(a.p, b.p, edge.twin.origin.p)}")

      print("\n")
      print("Las aristas que entran a d son:")
      for edge in a.hedgelist: # Exploramos las aristas que salen de a, para luego tomar sus twins, y tener las que llegan al vertice
        edge.twin.print()
        print(f"\t\t{calcular_angulo(hedge.origin.p, a.p, b.p)}")
      print("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ERROR XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")


def calcular_angulo(A,B,C):
  A_B = Point(A.x - B.x, A.y - B.y) # A-B
  C_B = Point(C.x - B.x, C.y - B.y) # C-B

  angulo = arg(A_B) - arg(C_B)

  if angulo < 0:
    return 2*pi + angulo
  return angulo

"""def calcular_angulo(A, B, C): # Calculamos el angulo ABC (Se supondra que AB Y AC tienen el interior del poligono a su izquierda)

  if orientation(A,B,C) == 0: # Si son colineales
    print("A, B, C son colineales")
    return pi

  if A.x == B.x: # Si A y B comparten coordenadas x
    print("A, B comparten coordenadas X")
    C_B = Point(C.x - B.x, C.y - B.y) # C-B
    if A.y < B.y: # Si A esta por debajo de B
      if C.x > B.x and C.y <= B.y:
        #print("Caso 1")
        return 2*pi - abs((3*pi/2)-arg(C_B))
      else:
        #print("Caso 2")
        return (3*pi/2)-arg(C_B)

    else: # Si A esta por encima de B
      if C.x > B.x and C.y >= B.y:
        #print("Caso 3")
        return (pi/2) - arg(C_B)
      else:
        #print("Caso 4")
        #print( arg(Point(C.x - B.x, C.y - B.y)) )
        return 2*pi - arg(C_B) + pi/2


  if B.x == C.x: # Si B y C comparten coordenadas x
    print("B, C comparten coordenadas X")
    A_B = Point(A.x - B.x, A.y - B.y) # A-B
    if B.y < C.y: # Si B esta por debajo de C
      if A.x > B.x and A.y >= B.y:
        return (3*pi/2) + arg(A_B)
      else:
        return arg(A_B) - (pi/2)

    else: # Si B esta por encima de C
      if A.x > B.x and A.y <= B.y:
        return arg(A_B) - (3*pi/2)
      else:
        return arg(A_B) + (pi/2)


  print("Caso Regular")
  #print(A.x, B.x)
  #print(B.x, C.x)
  m_AB = (A.y - B.y) / (A.x - B.x)
  m_BC = (B.y - C.y) / (B.x - C.x)

  if m_AB*m_BC == -1:
    return pi/2
  #print(m_AB, m_BC)
  ang = math.atan( (m_AB - m_BC) / (1 + m_AB*m_BC)  )
  print(f"-----> {ang}")
  if ang < 0: # Para siempre tener un angulo en [0,2pi)
    return 2*pi + ang
  return ang"""

"""for i in range(n_monotonos):
  fix_DCEL(D_list[i])"""

D_total = []
for d in D_list:
  D_total += d
fix_DCEL(D_total)

"""for i in range(n_monotonos):
  print(f"Diagonales del monotono {i+1}")
  j = 1
  for d in D_list[i]:
    print(f"Cara {j}")
    d.prev.print()
    d.print()
    d.next.print()
    j += 1
    print("\n")
  print("-----------------------------------------\n")"""

"""Faces = [None]*n_monotonos
for i in range(n_monotonos):
  Faces[i] = get_faces(D_list[i], i)
  print(f"El monotono {i+1} tiene {len(Faces[i])} caras")"""

"""D_total = []
for d in D_list:
  D_total += d"""

Faces_total = get_faces(D_total)

for f in Faces_total:
    f.print()
    n_vecinos = 0
    for edge in f.get_hedges():
      if not (edge.twin.incident_face is None):
        n_vecinos += 1
    print(f"Tiene {n_vecinos} caras vecinas")
    print("\n")

def DFS(Faces):
  Faces.sort(reverse=True) # Ordenamos las caras según las que tengan mas puntos coloreados, para asi comenzar de allí si es que otra cara de otro poligono coloreo algunos vertices de esta
  for f in Faces:
    if f.color == 'white':
      DFS_visit(f)

def DFS_visit(f):
  f.color = 'gray'
  f.colorear_vertices() # Aqui realizamos el coloreado de los vertices de la cara. Le agregamos el color faltante, o coloreamos todos sus vertices si no tiene ninguno coloreado

  for hedge in f.get_hedges(): # Vemos todas las hedges de la cara, cada hedge.twin tiene otra cara asociada, o None si es la externa
    other_f =  hedge.twin.incident_face
    if other_f is None: # Ignoramos la casa externa
      continue
    if other_f.color == 'white':
      DFS_visit(other_f)
  f.color = 'black'

def plot_faces(Faces):
  plt.figure(figsize=(8, 8))

  for f in Faces: # Exploramos todas las caras
    Hedges = f.get_hedges() # Obtenemos las aristas de la cara

    for edge in Hedges: # Graficaremos cada arista, asi como su punto origen con su color (arista a -> b con color c)
      a = edge.origin.p
      c = edge.origin.color
      b = edge.twin.origin.p

      #plt.scatter(a.x, a.y, color = c)
      plt.scatter(a.x, a.y, color=c, s=100, edgecolors='black')
      plt.plot([a.x, b.x], [a.y, b.y],color='blue')

  plt.xlabel('X')
  plt.ylabel('Y')
  plt.title('Polígono')
  plt.grid(True)
  plt.axis('equal')
  plt.show()

n_white = 0
n_black = 0
n_gray = 0

DFS(Faces_total)
"""for i in range(n_monotonos):
  DFS(Faces[i])
  print("----------")"""

plot_faces(Faces_total)


print(f"Hay {n_white} vertices blancos")
print(f"Hay {n_black} vertices negros")
print(f"Hay {n_gray} vertices grices")

print("\n")

C = [n_white, n_black, n_gray]
min_C = min(C)
if min_C == n_white:
  print("Los guardias se colocaran en los vertices blancos")
elif min_C == n_black:
  print("Los guardias se colocaran en los vertices negros")
else:
  print("Los guardias se colocaran en los vertices grices")